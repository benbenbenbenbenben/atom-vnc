// Generated by CoffeeScript 1.12.4
(function() {
  var VncPassword, VncView, keyMap, rfb, toRfbKeycode, url,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  const {clipboard} = require('electron').remote;
  const {BrowserWindow} = require('electron').remote;

  url = require('url');

  VncPassword = null;

  rfb = null;

  keyMap = null;

  toRfbKeycode = function(code, shift) {
    var j, key, len;
    if (keyMap == null) {
      keyMap = require('./keycodes.js');
    }
    for (j = 0, len = keyMap.length; j < len; j++) {
      key = keyMap[j];
      if (code === key[0]) {
        return key[shift ? 2 : 1];
      }
    }
    return null;
  };

  module.exports = VncView = (function(superClass) {
    extend(VncView, superClass);

    function VncView() {
      return VncView.__super__.constructor.apply(this, arguments);
    }

    VncView.prototype.initialize = function(params) {
      var checkClipboard, connectionParams, lastClipboard, view;
      if (rfb == null) {
        rfb = require('rfb2');
      }
      connectionParams = url.parse(params.uri);
      if (connectionParams.hostname === '') {
        connectionParams.hostname = '127.0.0.1';
      }
      this.connection = rfb.createConnection({
        host: connectionParams.hostname,
        port: connectionParams.port,
        encodings: [rfb.encodings.raw, rfb.encodings.copyRect, rfb.encodings.pseudoDesktopSize]
      });
      this.connection.autoUpdate = true;
      this.buttonStateBitset = 0;
      this.connection.on('connect', (function(_this) {
        return function() {
          _this.connected = true;
          _this.title = _this.connection.title;
          _this.trigger('title-changed');
          _this.offScreenCanvas.attr("width", _this.connection.width).attr("height", _this.connection.height);
          return _this.drawable.attr("width", _this.connection.width).attr("height", _this.connection.height);
        };
      })(this));
      // TODO: re-enable security (disabled because of atom imports)
      /*this.connection.params.credentialsCallback = (function(_this) {
        return function(cb) {
          var dialog, done, securityType;
          done = function(err, password) {
            if (!err) {
              return cb(password);
            }
            return this.connection.end();
          };
          securityType = _this.connection.securityType;
          console.log(securityType);

          if (securityType === rfb.security.VNC) {
            if (VncPassword == null) {
              VncPassword = require('./vnc-password');
            }
            return dialog = new VncPassword({
              host: _this.connection.params.host,
              port: _this.connection.params.port,
              callback: done
            });
          } else {
            return console.log("Unknown RFB security type: " + securityType);
          }
        };
      })(this);*/
      this.connection.on('rect', (function(_this) {
        return function(rect) {
          return _this.updateRectangle(rect);
        };
      })(this));
      this.connection.on('resize', (function(_this) {
        return function(size) {
          _this.offScreenCanvas.attr("width", size.width).attr("height", size.height);
          return _this.drawable.attr("width", size.width).attr("height", size.height);
        };
      })(this));
      this.connection.on('clipboard', function(text) {
        return clipboard.write(text);
      });
      view = this;
      lastClipboard = clipboard.read();
      checkClipboard = function() {
        var currentClipboard;
        currentClipboard = clipboard.read();
        if (lastClipboard === currentClipboard) {
          return;
        }
        lastClipboard = currentClipboard;
        return view.connection.updateClipboard(currentClipboard);
      };
      this.clipboardWatcher = setInterval(checkClipboard, 50);
      return this.ctx = this.drawable[0].getContext('2d');
    };

    VncView.prototype.updateRectangle = function(rect) {
      var b, canvasRectangle, g, i, j, r, ref, word;
      if (rect.encoding === rfb.encodings.raw) {
        canvasRectangle = this.ctx.createImageData(rect.width, rect.height);
        for (i = j = 0, ref = rect.buffer.length - 4; j <= ref; i = j += 4) {
          word = rect.buffer.readUInt32LE(i);
          r = (word & (this.connection.redMax << this.connection.redShift)) >> this.connection.redShift;
          g = (word & (this.connection.greenMax << this.connection.greenShift)) >> this.connection.greenShift;
          b = (word & (this.connection.blueMax << this.connection.blueShift)) >> this.connection.blueShift;
          canvasRectangle.data[i + 0] = r;
          canvasRectangle.data[i + 1] = g;
          canvasRectangle.data[i + 2] = b;
          canvasRectangle.data[i + 3] = 255;
        }
        this.offScreenCanvas[0].getContext("2d").putImageData(canvasRectangle, rect.x, rect.y);
        this.ctx.drawImage(this.offScreenCanvas[0], 0, 0);
      } else if (rect.encoding === rfb.encodings.copyRect) {
        this.ctx.drawImage(this.offScreenCanvas[0], rect.src.x, rect.src.y, rect.width, rect.height, rect.x, rect.y, rect.width, rect.height);
        this.offScreenCanvas[0].getContext("2d").drawImage(this.offScreenCanvas[0], rect.src.x, rect.src.y, rect.width, rect.height, rect.x, rect.y, rect.width, rect.height);
      } else {
        console.log("Unsupported rectangle encoding: " + rect.encoding);
      }
      return this.drawable.bind('mousewheel', (function(_this) {
        return function(event) {
          var delta, offset, x, y;
          offset = _this.drawable.offset();
          x = event.pageX - offset.left;
          y = event.pageY - offset.top;
          delta = event.originalEvent.wheelDelta;
          if (delta > 0) {
            _this.connection.pointerEvent(x, y, _this.buttonStateBitset | 1 << 3);
          } else {
            _this.connection.pointerEvent(x, y, _this.buttonStateBitset | 1 << 4);
          }
          _this.connection.pointerEvent(x, y, _this.buttonStateBitset);
          return console.log('Wheel!', event.originalEvent.wheelDelta);
        };
      })(this));
    };

    VncView.prototype.mouseMove = function(event, element) {
      var offset, x, y;
      if (!this.connected) {
        return;
      }
      offset = element.offset();
      x = event.pageX - offset.left;
      y = event.pageY - offset.top;
      return this.connection.pointerEvent(x, y, this.buttonStateBitset);
    };

    VncView.prototype.mouseUp = function(event, element) {
      var offset, x, y;
      this.buttonStateBitset &= ~(1 << (event.which - 1));
      offset = element.offset();
      x = event.pageX - offset.left;
      y = event.pageY - offset.top;
      return this.connection.pointerEvent(x, y, this.buttonStateBitset);
    };

    VncView.prototype.mouseDown = function(event, element) {
      var offset, x, y;
      this.buttonStateBitset |= 1 << (event.which - 1);
      offset = element.offset();
      x = event.pageX - offset.left;
      y = event.pageY - offset.top;
      return this.connection.pointerEvent(x, y, this.buttonStateBitset);
    };

    VncView.prototype.keyUp = function(event, element) {
      var keyCode;
      keyCode = toRfbKeycode(event.keyCode, event.shiftKey);
      return this.connection.keyEvent(keyCode, 0);
    };

    VncView.prototype.keyDown = function(event, element) {
      var keyCode;
      keyCode = toRfbKeycode(event.keyCode, event.shiftKey);
      return this.connection.keyEvent(keyCode, 1);
    };

    VncView.prototype.disableEvent = function() {
      return false;
    };

    VncView.content = function() {
      return this.div({
        "class": 'vnc pane-item'
      }, (function(_this) {
        return function() {
          _this.canvas({
            width: 80,
            height: 80,
            tabindex: '1',
            outlet: 'drawable',
            mousemove: 'mouseMove',
            mousedown: 'mouseDown',
            mouseup: 'mouseUp',
            mousewheel: 'mouseWheel',
            keyup: 'keyUp',
            keydown: 'keyDown',
            keypress: 'disableEvent',
            contextmenu: 'disableEvent'
          });
          return _this.canvas({
            id: 'offscreen',
            outlet: 'offScreenCanvas'
          });
        };
      })(this));
    };

    VncView.prototype.destroy = function() {
      this.connection.end();
      clearInterval(this.clipboardWatcher);
      return this.detach();
    };

    VncView.prototype.getTitle = function() {
      return this.title;
    };

    VncView.prototype.getIconName = function() {
      return 'telescope';
    };

    return VncView;

  })(BrowserWindow);

}).call(this);
